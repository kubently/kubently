# Kubently Helm Chart Values

# API Configuration (includes A2A server)
api:
  replicaCount: 3  # Can scale horizontally with connection registry
  
  image:
    repository: ghcr.io/kubently/kubently
    pullPolicy: IfNotPresent
    tag: "latest"
  
  service:
    type: ClusterIP
    port: 8080      # Changed from 5000 to match container port
    targetPort: 8080
  
  resources:
    requests:
      cpu: 250m  # Slightly increased for A2A
      memory: 384Mi  # Increased to handle both servers
    limits:
      cpu: 1000m
      memory: 768Mi
  
  # API Keys for authentication
  # OPTION 1 (RECOMMENDED): Use existing secret (managed separately)
  # Set existingSecret to the name of your manually created secret
  # The secret must contain a 'keys' field with newline-separated API keys
  # Example:
  #   kubectl create secret generic my-api-keys \
  #     --from-literal=keys="$(cat <<EOF
  #   key1
  #   key2
  #   EOF
  #   )"
  existingSecret: ""  # e.g., "kubently-api-keys"

  # OPTION 2: Provide keys directly in values (NOT recommended for production)
  # Only used if existingSecret is not set
  # Format: each key on a new line (just the key value, no "service:" prefix needed)
  # Example: apiKeys: ["abc123...", "def456..."]
  apiKeys: []
  
  env:
    LOG_LEVEL: "INFO"
    MAX_COMMANDS_PER_FETCH: "10"
    COMMAND_TIMEOUT: "30"
    SESSION_TTL: "300"
    PORT: "8080"
    API_PORT: "8080"

# ============================================================================
# Executor Configuration
# ============================================================================
# The executor runs IN the cluster being monitored and executes kubectl
# commands on behalf of AI agents. It connects back to the API server.
#
# Typical deployment pattern:
#   - API server: Central cluster (with Redis)
#   - Executor: Each monitored cluster (dev, staging, prod)
#
# Each executor needs:
#   1. A unique clusterId (identifies which cluster it monitors)
#   2. An authentication token (created via admin API)
#   3. The API server URL (where to send results)
# ============================================================================
executor:
  # Enable/disable executor deployment
  # Set to false if deploying only the API server (central cluster)
  # Set to true if deploying to a monitored cluster
  enabled: true

  # NOTE: Executors always run with 1 replica (no replicaCount setting)
  # Each executor represents a unique cluster identity (clusterId)
  # Running multiple replicas would create duplicate agents for the same cluster
  # For high availability, deploy the executor using a Deployment (default behavior)
  # which ensures automatic pod restart if it fails

  # ----------------------------------------------------------------------------
  # Container Configuration
  # ----------------------------------------------------------------------------
  image:
    repository: ghcr.io/kubently/kubently-executor
    tag: "latest"
    pullPolicy: IfNotPresent

  resources:
    requests:
      cpu: 50m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi

  # ----------------------------------------------------------------------------
  # Authentication & Cluster Identity
  # ----------------------------------------------------------------------------
  # These settings tell the executor WHICH cluster it's monitoring and
  # HOW to authenticate with the central API server

  # Cluster identifier (must be unique across all executors)
  # If empty, uses the Kubernetes namespace name as the cluster ID
  # Example: "prod-us-west", "staging-eu", "dev-local"
  clusterId: ""

  # Executor authentication token
  # This token is created via the admin API and stored in Redis
  # OPTION 1 (RECOMMENDED): Use existing secret (managed separately)
  existingSecret: ""  # e.g., "kubently-executor-token"
  existingSecretKey: "token"  # Key within the secret containing the token

  # OPTION 2: Provide token directly (NOT recommended for production)
  # Only used if existingSecret is not set
  # REQUIRED: You must provide a token value - deployment will fail if both are empty
  token: ""  # e.g., "my-secure-token-here" or set via --set executor.token=<value>

  # API server URL (where executor sends command results)
  # REQUIRED: You must explicitly set this based on your deployment topology
  #
  # Examples:
  #   Same cluster (executor + API in same cluster):
  #     apiUrl: "http://kubently-api:8080"
  #
  #   Cross-cluster with external domain (executor in remote cluster):
  #     apiUrl: "https://kubently-api.company.com"
  #
  #   Cross-cluster with internal load balancer:
  #     apiUrl: "http://kubently-api.central-cluster.svc.cluster.local:8080"
  apiUrl: ""

  # ----------------------------------------------------------------------------
  # Security & Command Whitelist
  # ----------------------------------------------------------------------------
  # Controls which kubectl commands the executor is allowed to run
  # This is a critical security boundary - AI agents request commands,
  # but the executor validates them before execution

  security:
    # Security mode determines the baseline set of allowed commands
    # Options:
    #   - readOnly: Safe read operations only (get, describe, logs)
    #   - extendedReadOnly: Includes debugging (port-forward, exec)
    #   - fullAccess: Advanced operations (use with extreme caution)
    mode: "readOnly"

    # Dynamic command whitelist (validates commands before execution)
    commandWhitelist:
      # Enable whitelist validation (disable for testing only)
      enabled: true

      # Add custom kubectl verbs beyond the mode defaults
      # Example: ["auth", "certificate", "cluster-info"]
      customVerbs: []

      # Add extra allowed flags beyond the mode defaults
      # Example: ["--raw", "--field-selector", "--chunk-size"]
      extraFlags: []

      # Add forbidden patterns beyond the immutable baseline
      # The baseline always blocks: delete, apply, create, tokens, shell injection
      # Example: ["rm", "sudo", "sh", "bash"]
      extraForbiddenPatterns: []

      # Restrict access to specific Kubernetes resources
      # Example: ["serviceaccounts", "roles", "rolebindings"]
      restrictedResources: []

      # Runtime limits for command execution
      maxArguments: 20        # Max number of arguments per command
      timeoutSeconds: 30      # Command execution timeout
      reloadInterval: 30      # How often to reload whitelist config (seconds)

  # ----------------------------------------------------------------------------
  # RBAC Configuration
  # ----------------------------------------------------------------------------
  # Defines what Kubernetes resources the executor ServiceAccount can access
  # If not specified, uses default rules with generic read access
  #
  # NOTE: This is separate from the command whitelist above:
  #   - rbacRules: What the ServiceAccount CAN access
  #   - commandWhitelist: What commands the AI agent CAN request
  rbacRules: []
  # Example custom rules:
  # rbacRules:
  # - apiGroups: [""]
  #   resources: ["pods", "services", "endpoints"]
  #   verbs: ["get", "list", "watch"]
  # - apiGroups: ["apps"]
  #   resources: ["deployments", "replicasets"]
  #   verbs: ["get", "list", "watch"]

  # ----------------------------------------------------------------------------
  # Capability Reporting (Optional)
  # ----------------------------------------------------------------------------
  # When enabled, executors advertise their command whitelist configuration
  # to the central API. This allows the agent to know what each cluster
  # can do before sending commands.
  #
  # This feature is completely optional - if disabled or if reporting fails,
  # the system continues to function normally (graceful degradation).
  capabilities:
    # Enable capability reporting to central API
    # Set to true to advertise what this executor can do
    enabled: false

    # Heartbeat interval (seconds) to refresh capability TTL
    # Capabilities expire after 1 hour by default; heartbeat keeps them alive
    heartbeatInterval: 300  # 5 minutes

  # ----------------------------------------------------------------------------
  # Environment Variables
  # ----------------------------------------------------------------------------
  env:
    LOG_LEVEL: "INFO"

# ============================================================================
# Emergency/Admin Override
# ============================================================================
# CRITICAL SAFETY FLAG: Must be explicitly set to true to enable fullAccess mode
# This prevents accidental deployment of executors with dangerous permissions
#
# fullAccess mode allows commands like: exec, cp, run, attach, proxy
# Only enable this if you understand the security implications
fullAccessAcknowledged: false

# Redis Configuration
redis:
  enabled: true
  auth:
    enabled: true  # CRITICAL: Enable authentication for production

    # Reference to manually created secret containing Redis password
    # The secret must have a 'password' key
    # Default expects: kubently-redis-password
    # Create with:
    #   kubectl create secret generic kubently-redis-password \
    #     --from-literal=password="$(openssl rand -base64 32)" -n kubently
    # Or specify a different secret name:
    #   existingSecret: "my-custom-redis-secret"
    existingSecret: "kubently-redis-password"

  architecture: standalone
  master:
    persistence:
      enabled: true  # Uses StatefulSet volumeClaimTemplates for persistent storage
      size: 2Gi      # PersistentVolume size - stores executor tokens, sessions, cluster state
      storageClass: ""  # Uses cluster default StorageClass if empty
    resources:
      requests:
        cpu: 100m
        memory: 256Mi
      limits:
        cpu: 500m
        memory: 512Mi

# Ingress Configuration
# This chart follows the "user brings certificate" pattern (Bitnami/ArgoCD standard)
# TLS certificates must be created separately and referenced via secretName
# See examples/ directory for TLS setup patterns
ingress:
  enabled: false
  className: nginx

  # Annotations are passed through directly
  # For cert-manager integration, add cert-manager.io/cluster-issuer annotation
  # For other ingress controllers, add appropriate annotations
  annotations: {}
  # Examples:
  # cert-manager.io/cluster-issuer: "letsencrypt-prod"
  # nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
  # nginx.ingress.kubernetes.io/proxy-read-timeout: "60"

  hosts:
    - host: api.kubently.local
      paths:
        - path: /
          pathType: Prefix

  # TLS certificates (must be created separately)
  # See examples/ directory for different TLS patterns
  tls: []
  # Example:
  # tls:
  #   - secretName: kubently-api-tls  # You must create this secret
  #     hosts:
  #       - api.kubently.com

# Autoscaling Configuration
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# Service Account
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use
  name: ""

# Pod Security Context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

# Security Context
securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000

# Node Selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity: {}

# Network Policy
networkPolicy:
  enabled: false
  
# Pod Disruption Budget
podDisruptionBudget:
  enabled: false
  minAvailable: 1
  # maxUnavailable: 1