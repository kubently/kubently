# Test values for Kubently Helm deployment
# This file contains all the configuration needed for testing

# TLS Configuration for testing (using self-signed certificates)
tls:
  enabled: true  # Enable TLS by default
  mode: "internal"  # Use self-signed certificates for local testing
  
  internal:
    issuer: "self-signed-issuer"
    serviceName: "kubently-api.kubently.svc.cluster.local"
    duration: "8760h"  # 1 year for dev certificates
    renewBefore: "720h"  # Renew 30 days before expiry

api:
  replicaCount: 2
  
  image:
    repository: kubently/api
    tag: latest
    pullPolicy: IfNotPresent
  
  service:
    type: ClusterIP
    port: 8080
    targetPort: 8080
  
  # API Keys for authentication
  # RECOMMENDED: Create secret manually before deploying:
  #   kubectl create secret generic kubently-api-keys \
  #     --from-literal=keys="your-api-key-here" \
  #     --namespace kubently
  # Then reference it here:
  # existingSecret: "kubently-api-keys"

  # For quick testing, you can provide keys inline (NOT for production):
  apiKeys: []
  
  # OAuth/OIDC Configuration (for human users)
  oidc:
    enabled: true
    issuer: "http://localhost:9000"  # Mock provider for testing
    clientId: "kubently-cli"
    jwksUri: "http://localhost:9000/jwks"
    audience: "kubently-cli"
  
  env:
    # Core API configuration
    LOG_LEVEL: "INFO"
    MAX_COMMANDS_PER_FETCH: "10"
    COMMAND_TIMEOUT: "30"
    SESSION_TTL: "300"
    PORT: "8080"
    API_PORT: "8080"
    
    # OAuth/OIDC Configuration
    OAUTH_ENABLED: "true"
    OIDC_ENABLED: "true"
    OIDC_ISSUER: "http://localhost:9000"
    OIDC_CLIENT_ID: "kubently-cli"
    OIDC_JWKS_URI: "http://localhost:9000/jwks"
    OIDC_AUDIENCE: "kubently-cli"
    
    # A2A Configuration - CRITICAL for agent functionality (A2A is core, always enabled)
    A2A_EXTERNAL_URL: "http://localhost:8080/a2a/"  # A2A is mounted at /a2a path
    
    # LLM Configuration (from .env) - API key is in separate secret
    LLM_PROVIDER: "anthropic-claude"
    # Using Google Gemini 2.5 Flash (standard API, not Vertex AI)

    ANTHROPIC_MODEL_NAME: "claude-sonnet-4-20250514"
    # GOOGLE_MODEL_NAME: "gemini-2.5-flash"  # For our code reference
    # GOOGLE_GEMINI_MODEL_NAME: "gemini-2.5-flash"  # For cnoe-agent-utils library

    # Anthropic Context Management - Automatically clears tool results to prevent context overflow
    # Requires langchain-anthropic >=0.3.21
    ANTHROPIC_CONTEXT_CLEARING: "true"
    
    # CRITICAL: API URL for internal service-to-service calls
    # Must use service name, not localhost, for pod-to-service communication
    KUBENTLY_API_URL: "http://kubently-api:8080"
    
    # Debug mode for troubleshooting
    A2A_SERVER_DEBUG: "true"

    # LangSmith Tracing (Production Observability)
    # LANGSMITH_API_KEY is managed via separate secret (see langsmith.apiKeySecret)
    LANGSMITH_TRACING: "true"  # Enable automatic tracing
    LANGSMITH_PROJECT: "kubently-production"  # Project name in LangSmith UI
    LANGSMITH_ENDPOINT: "https://api.smith.langchain.com"  # LangSmith API endpoint

  resources:
    requests:
      cpu: 200m
      memory: 512Mi
    limits:
      cpu: 1000m
      memory: 2Gi

executor:
  enabled: true
  replicaCount: 1

  image:
    repository: kubently/executor
    tag: latest
    pullPolicy: IfNotPresent

  # Cluster ID for the executor
  clusterId: "kind"

  # Token for executor authentication
  # IMPORTANT: Set via --set executor.token=<token> during helm install
  # For local dev, use secrets/deploy-test.sh which loads from secrets/kubently-tokens.env
  token: ""

  # Reference an existing secret (recommended for production)
  # Create secret first: kubectl create secret generic my-executor-token --from-literal=token=<secure-token>
  # Then set: existingSecret=my-executor-token
  # existingSecret: ""
  # existingSecretKey: "token"  # Optional, defaults to "token"
  
  env:
    LOG_LEVEL: "INFO"
  
  # Use default RBAC rules (generic read access to all APIs)
  # Uncomment and modify to use custom rules:
  # rbacRules:
  # - apiGroups: [""]
  #   resources: ["pods", "services", "endpoints", "nodes", "namespaces", "configmaps", "secrets", "pods/log", "events"]
  #   verbs: ["get", "list", "watch"]
  # - apiGroups: ["apps"]
  #   resources: ["deployments", "replicasets", "daemonsets", "statefulsets"]
  #   verbs: ["get", "list", "watch"]
  # - apiGroups: ["batch"]
  #   resources: ["jobs", "cronjobs"]
  #   verbs: ["get", "list", "watch"]
  # - apiGroups: ["networking.k8s.io"]
  #   resources: ["ingresses", "networkpolicies"]
  #   verbs: ["get", "list", "watch"]
  # - apiGroups: ["metrics.k8s.io"]
  #   resources: ["pods", "nodes"]
  #   verbs: ["get", "list"]
  
  resources:
    requests:
      cpu: 50m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi

# Kubently Executor Configuration
kubentlyExecutor:
  enabled: true
  
  # Security mode for command whitelist
  securityMode: "readOnly"
  
  # Dynamic command whitelist configuration
  commandWhitelist:
    enabled: true
    customVerbs: []
    extraFlags: []
    extraForbiddenPatterns: []

redis:
  enabled: true
  architecture: standalone
  auth:
    enabled: false
  master:
    persistence:
      enabled: false

# Ingress configuration (disabled for local testing)
ingress:
  enabled: false

# Service account configuration
serviceAccount:
  create: true
  name: kubently-executor

# RBAC configuration
rbac:
  create: true

# Pod security context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

# Container security context
securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 1000

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity: {}

# Image pull secrets
imagePullSecrets: []

# Name override
nameOverride: ""

# Full name override
fullnameOverride: ""